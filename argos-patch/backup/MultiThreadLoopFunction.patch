diff --git a/src/extensions/my_loop_functions.cpp b/src/extensions/my_loop_functions.cpp
index 0b75836..31a3ddf 100644
--- a/src/extensions/my_loop_functions.cpp
+++ b/src/extensions/my_loop_functions.cpp
@@ -6,11 +6,36 @@ namespace argos {
    /****************************************/
    /****************************************/
 
+   std::vector<CMyLoopFunctions::STrackedEntity> CMyLoopFunctions::m_vecTrackedEntities;
+   std::map<std::string, UInt32> CMyLoopFunctions::m_mapEntityIDTrackedEntityIndex;
+
+   /****************************************/
+   /****************************************/
+
+   void CMyLoopFunctions::Iteration(CControllableEntity* cControllableEntity) {
+      STrackedEntity& s_tracked_entity = m_vecTrackedEntities[
+         m_mapEntityIDTrackedEntityIndex[cControllableEntity->GetRootEntity().GetId()]
+      ];
+      SAnchor& s_origin_anchor = s_tracked_entity.EmbodiedEntity->GetOriginAnchor();
+      s_tracked_entity.LogFile << s_origin_anchor.Position << ',' << s_origin_anchor.Orientation;
+      if(s_tracked_entity.DebugEntity) {
+         CDebugEntity::TMessageVec& tMessageVec = s_tracked_entity.DebugEntity->GetMessages();
+         for(std::string strMessage: tMessageVec) {
+            s_tracked_entity.LogFile << ',' << strMessage;
+         }
+      }
+      s_tracked_entity.LogFile << std::endl;
+   }
+
+   /****************************************/
+   /****************************************/
+
    void CMyLoopFunctions::Init(TConfigurationNode& t_tree) {
       system("rm -rf logs");
       system("mkdir -p logs");
       /* create a vector of tracked entities */
       CEntity::TVector& tRootEntityVector = GetSpace().GetRootEntityVector();
+      UInt32 unEntityCount = 0;
       for(CEntity* pc_entity : tRootEntityVector) {
          CComposableEntity* pcComposable = dynamic_cast<CComposableEntity*>(pc_entity);
          if(pcComposable == nullptr) {
@@ -25,6 +50,8 @@ namespace argos {
             catch(CARGoSException& ex) {
                m_vecTrackedEntities.emplace_back(pc_entity, &cBody, nullptr);
             }
+            m_mapEntityIDTrackedEntityIndex[pc_entity->GetId()] = unEntityCount;
+            unEntityCount++;
          }
          catch(CARGoSException& ex) {
             /* only track entities with bodies */
@@ -37,17 +64,7 @@ namespace argos {
    /****************************************/
 
    void CMyLoopFunctions::PostStep() {
-      for(STrackedEntity& s_tracked_entity : m_vecTrackedEntities) {
-         SAnchor& s_origin_anchor = s_tracked_entity.EmbodiedEntity->GetOriginAnchor();
-         s_tracked_entity.LogFile << s_origin_anchor.Position << ',' << s_origin_anchor.Orientation;
-         if(s_tracked_entity.DebugEntity) {
-            CDebugEntity::TMessageVec& tMessageVec = s_tracked_entity.DebugEntity->GetMessages();
-            for(std::string strMessage: tMessageVec) {
-               s_tracked_entity.LogFile << ',' << strMessage;
-            }
-         }
-         s_tracked_entity.LogFile << std::endl;
-      }
+      GetSpace().IterateOverControllableEntities(Iteration);
    }
    
    /****************************************/
diff --git a/src/extensions/my_loop_functions.h b/src/extensions/my_loop_functions.h
index e4d8d04..25bf763 100644
--- a/src/extensions/my_loop_functions.h
+++ b/src/extensions/my_loop_functions.h
@@ -40,7 +40,9 @@ namespace argos {
          std::ofstream LogFile;
       };
 
-      std::vector<STrackedEntity> m_vecTrackedEntities;
+      static std::vector<STrackedEntity> m_vecTrackedEntities;
+      static std::map<std::string, UInt32> m_mapEntityIDTrackedEntityIndex;
+      static void Iteration(CControllableEntity* cControllableEntity);
    };
 }
 
diff --git a/src/extensions/replay_loop_functions.cpp b/src/extensions/replay_loop_functions.cpp
index 907429a..691c5c0 100644
--- a/src/extensions/replay_loop_functions.cpp
+++ b/src/extensions/replay_loop_functions.cpp
@@ -6,6 +6,71 @@ namespace argos {
    /****************************************/
    /****************************************/
 
+   std::vector<CReplayLoopFunctions::STrackedEntity> CReplayLoopFunctions::m_vecTrackedEntities;
+   std::map<std::string, UInt32> CReplayLoopFunctions::m_mapEntityIDTrackedEntityIndex;
+
+   bool CReplayLoopFunctions::m_bDrawGoalFlag = false;
+   bool CReplayLoopFunctions::m_bDrawDebugArrowsFlag = false;
+   bool CReplayLoopFunctions::m_bDrawTrackFlag = false;
+   UInt32 CReplayLoopFunctions::m_unDrawTrackEveryXStep = 1;
+   std::vector<UInt32> CReplayLoopFunctions::m_vecDrawTrackKeyFrame;
+   std::vector<CColor> CReplayLoopFunctions::m_vecColorMap;
+   std::vector<CColor> CReplayLoopFunctions::m_vecLightColorMap;
+   UInt32 CReplayLoopFunctions::m_unStepCount;
+
+   /****************************************/
+   /****************************************/
+
+   void CReplayLoopFunctions::Iteration(CControllableEntity* cControllableEntity) {
+      STrackedEntity& s_tracked_entity = m_vecTrackedEntities[
+         m_mapEntityIDTrackedEntityIndex[cControllableEntity->GetRootEntity().GetId()]
+      ];
+
+      int bufferLength = 4096;
+      char buff[bufferLength];
+      if (!fgets(buff, bufferLength, s_tracked_entity.LogFile))
+         exit(0);
+      std::string strLine = buff;
+      // strip \n from end
+      strLine.erase(std::remove(strLine.begin(), strLine.end(), '\n'), strLine.end());
+
+      // split by ,
+      std::vector<std::string> vecWordList;
+      std::stringstream strstreamLineStream(strLine);
+      while (strstreamLineStream.good()) {
+         std::string substr;
+         std::getline(strstreamLineStream, substr, ',' );
+         vecWordList.push_back(substr);
+      }
+
+      CVector3 CPositionV3(0,0,0);
+      CQuaternion COrientationQ(0,0,0,0);
+      // get Position
+      if (vecWordList.size() >= 3) {
+         CPositionV3.SetX(std::stod(vecWordList[0]));
+         CPositionV3.SetY(std::stod(vecWordList[1]));
+         CPositionV3.SetZ(std::stod(vecWordList[2]));
+      }
+      if (m_bDrawTrackFlag == true) {
+         s_tracked_entity.vecTrack.push_back(CPositionV3);
+         if ((m_vecDrawTrackKeyFrame.size() > 0) && (m_unStepCount == m_vecDrawTrackKeyFrame[0]))
+            s_tracked_entity.vecKeyFrame.emplace_back(CPositionV3);
+      }
+      // get Orientation
+      if (vecWordList.size() >= 6) {
+         CRadians CX, CY, CZ;
+         CZ.FromValueInDegrees(std::stod(vecWordList[3]));
+         CY.FromValueInDegrees(std::stod(vecWordList[4]));
+         CX.FromValueInDegrees(std::stod(vecWordList[5]));
+         COrientationQ.FromEulerAngles(CZ, CY, CX);
+      }
+
+      s_tracked_entity.EmbodiedEntity->MoveTo(CPositionV3, COrientationQ, false, true);
+   }
+
+   /****************************************/
+   /****************************************/
+
    void CReplayLoopFunctions::Init(TConfigurationNode& t_tree) {
       m_unStepCount = 0;
       /* read log file folder from replay_input_folder.txt */
@@ -68,7 +133,6 @@ namespace argos {
       UInt16 unColorMapIndex = 0;
       UInt16 unEntityCount = 0;
       for(CEntity* pc_entity : tRootEntityVector) {
-         unEntityCount++;
          unColorMapIndex += unColorMapStepLength;
          CComposableEntity* pcComposable = dynamic_cast<CComposableEntity*>(pc_entity);
          if(pcComposable == nullptr) {
@@ -86,6 +150,8 @@ namespace argos {
             catch(CARGoSException& ex) {
                m_vecTrackedEntities.emplace_back(pc_entity, &cBody, nullptr, strLogFolder, cColor);
             }
+            m_mapEntityIDTrackedEntityIndex[pc_entity->GetId()] = unEntityCount;
+            unEntityCount++;
          }
          catch(CARGoSException& ex) {
             /* only track entities with bodies */
@@ -98,6 +164,8 @@ namespace argos {
    /****************************************/
 
    void CReplayLoopFunctions::PreStep() {
+      GetSpace().IterateOverControllableEntities(Iteration);
+      /*
       std::map<std::string, CVector3> mapPosition;
       std::map<std::string, CQuaternion> mapOrientation;
       std::map<std::string, std::string> mapParent;
@@ -403,6 +471,7 @@ namespace argos {
       if ((m_vecDrawTrackKeyFrame.size() > 0) && (m_unStepCount == m_vecDrawTrackKeyFrame[0]))
          m_vecDrawTrackKeyFrame.erase(m_vecDrawTrackKeyFrame.begin());
       m_unStepCount++;
+      */
    }
    
    /****************************************/
diff --git a/src/extensions/replay_loop_functions.h b/src/extensions/replay_loop_functions.h
index b2c602b..e319ea8 100644
--- a/src/extensions/replay_loop_functions.h
+++ b/src/extensions/replay_loop_functions.h
@@ -59,16 +59,29 @@ namespace argos {
          std::vector<SKeyFrame> vecKeyFrame;
       };
 
-      std::vector<STrackedEntity> m_vecTrackedEntities;
-
-      bool m_bDrawGoalFlag = false;
-      bool m_bDrawDebugArrowsFlag = false;
-      bool m_bDrawTrackFlag = false;
-      UInt32 m_unDrawTrackEveryXStep = 1;
-      std::vector<UInt32> m_vecDrawTrackKeyFrame;
-      std::vector<CColor> m_vecColorMap;
-      std::vector<CColor> m_vecLightColorMap;
-      UInt32 m_unStepCount;
+      /*
+      static bool m_bDrawGoalFlag = false;
+      static bool m_bDrawDebugArrowsFlag = false;
+      static bool m_bDrawTrackFlag = false;
+      static UInt32 m_unDrawTrackEveryXStep = 1;
+      static std::vector<UInt32> m_vecDrawTrackKeyFrame;
+      static std::vector<CColor> m_vecColorMap;
+      static std::vector<CColor> m_vecLightColorMap;
+      static UInt32 m_unStepCount;
+      */
+
+      static bool m_bDrawGoalFlag;
+      static bool m_bDrawDebugArrowsFlag;
+      static bool m_bDrawTrackFlag;
+      static UInt32 m_unDrawTrackEveryXStep;
+      static std::vector<UInt32> m_vecDrawTrackKeyFrame;
+      static std::vector<CColor> m_vecColorMap;
+      static std::vector<CColor> m_vecLightColorMap;
+      static UInt32 m_unStepCount;
+
+      static std::vector<STrackedEntity> m_vecTrackedEntities;
+      static std::map<std::string, UInt32> m_mapEntityIDTrackedEntityIndex;
+      static void Iteration(CControllableEntity* cControllableEntity);
    };
 }
 
diff --git a/src/scripts/libreplayer/replayer.in.py b/src/scripts/libreplayer/replayer.in.py
index 0e96f18..43b5655 100644
--- a/src/scripts/libreplayer/replayer.in.py
+++ b/src/scripts/libreplayer/replayer.in.py
@@ -18,10 +18,14 @@ DrawDebugArrowsFlag = None
 DrawTrackFlag = None
 DrawTrackKeyFrame = None
 DrawTrackEveryXStep = None
+MultiThreads = None
 for opt, value in optlist:
     if opt == "-i":
         InputFolder = value
         print("Inputseed provided:", InputFolder)
+    elif opt == "-m":
+        MultiThreads = int(value) 
+        print("Multi threads provided:", MultiThreads)
     elif opt == "-g":
         DrawGoalFlag = True
         print("DrawGoalFlag provided:", DrawGoalFlag)
@@ -61,6 +65,10 @@ if DrawTrackEveryXStep == None :
     DrawTrackEveryXStep = 1
     print("DrawTrackEveryXStep not provided, draw every step by default, use -e to specify.")
 
+if MultiThreads == None :
+    MultiThreads = 0
+    print("MultiThreads not provided, using:", MultiThreads)
+
 #----------------------------------------------------------------------------------------------
 # read InputFolder and extract .log
 def findRobotLogs(path, robotType) :
diff --git a/src/scripts/libreplayer/replayer_template.in.argos b/src/scripts/libreplayer/replayer_template.in.argos
index f609cd7..c783676 100755
--- a/src/scripts/libreplayer/replayer_template.in.argos
+++ b/src/scripts/libreplayer/replayer_template.in.argos
@@ -5,7 +5,7 @@
   <!-- * General configuration * -->
   <!-- ************************* -->
   <framework>
-    <system threads="0" />
+    <system threads="MULTITHREADS" />
     <experiment length="TOTALLENGTH" ticks_per_second="5" random_seed="RANDOMSEED" />
   </framework>
   
diff --git a/src/scripts/replay.in.py b/src/scripts/replay.in.py
index cb005d0..1210ecf 100644
--- a/src/scripts/replay.in.py
+++ b/src/scripts/replay.in.py
@@ -9,6 +9,7 @@ generate_argos_file("@CMAKE_CURRENT_BINARY_DIR@/libreplayer/replayer_template.ar
     [
         ["RANDOMSEED",        str(Inputseed)],  # Inputseed is inherit from createArgosScenario.py
         ["TOTALLENGTH",       str((Experiment_length or 0)/5)],
+        ["MULTITHREADS",      str(MultiThreads)],  # MultiThreads is inherit from createArgosScenario.py
         ["DRONES",            drone_xml], 
         ["PIPUCKS",           pipuck_xml], 
         ["SIMULATION_SETUP",  generate_physics_media_loop_visualization("@CMAKE_BINARY_DIR@", False, "white", True)],
